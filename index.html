<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nitro Drift: Apex Reckoning - Enhanced</title>
    <!-- Tailwind CSS for basic UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark blue background */
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            background-color: #0f0f1a; /* Even darker background for game area */
            border: 4px solid #4a4a6a;
            border-radius: 12px;
            display: block;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            max-width: 95vw; /* Max width relative to viewport */
            max-height: 80vh; /* Max height relative to viewport */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), 0 0 40px rgba(0, 200, 255, 0.2);
        }
        .controls-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 95vw;
            padding: 10px 0;
            gap: 10px;
        }
        .control-button {
            background-color: #007bff; /* Blue */
            color: white;
            padding: 15px 25px;
            border-radius: 50px; /* Pill shape */
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            user-select: none; /* Prevent text selection on touch */
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.4);
            border: 2px solid #0056b3;
            flex-grow: 1; /* Allow buttons to grow */
            text-align: center;
            max-width: 150px; /* Limit button width */
        }
        .control-button:active {
            background-color: #0056b3; /* Darker blue on press */
            transform: scale(0.98);
            box-shadow: 0 2px 5px rgba(0, 123, 255, 0.6);
        }
        .control-button.nitro {
            background-color: #ff4500; /* Orange-red for nitro */
            border-color: #cc3700;
            box-shadow: 0 4px 10px rgba(255, 69, 0, 0.4);
        }
        .control-button.nitro:active {
            background-color: #cc3700;
            box-shadow: 0 2px 5px rgba(255, 69, 0, 0.6);
        }
        .control-button.fire {
            background-color: #28a745; /* Green for fire */
            border-color: #1e7e34;
            box-shadow: 0 4px 10px rgba(40, 167, 69, 0.4);
        }
        .control-button.fire:active {
            background-color: #1e7e34;
            box-shadow: 0 2px 5px rgba(40, 167, 69, 0.6);
        }

        .game-info {
            width: 100%;
            max-width: 95vw;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff; /* Cyan */
        }
        .health-bar-container {
            width: 150px;
            height: 20px;
            background-color: #4a4a6a;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #00ffff;
        }
        .health-bar {
            height: 100%;
            background-color: #28a745; /* Green */
            width: 100%; /* Default to full */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
        }
        .health-bar.low {
            background-color: #dc3545; /* Red */
        }

        /* Message Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            max-width: 80vw;
            color: #e0e0e0;
            border: 2px solid #00ffff;
        }
        .modal-content h2 {
            font-size: 2em;
            margin-bottom: 15px;
            color: #00ffff;
        }
        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 25px;
        }
        .modal-content button {
            background-color: #007bff;
            color: white;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        }
        .modal-content button:hover {
            background-color: #0056b3;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            color: #00ffff;
            font-size: 2em;
            font-weight: bold;
        }
        .spinner {
            border: 8px solid rgba(0, 255, 255, 0.2);
            border-top: 8px solid #00ffff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .control-button {
                padding: 12px 20px;
                font-size: 1em;
            }
            .game-info {
                font-size: 1em;
            }
            .health-bar-container {
                width: 120px;
                height: 18px;
            }
            .modal-content {
                padding: 20px;
            }
            .modal-content h2 {
                font-size: 1.5em;
            }
            .modal-content p {
                font-size: 1em;
            }
            .modal-content button {
                padding: 10px 25px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="spinner"></div>
        Loading Nitro Drift...
    </div>

    <div class="game-info">
        <div>Score: <span id="scoreDisplay">0</span></div>
        <div class="health-bar-container">
            <div id="healthBar" class="health-bar"></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls-container">
        <button id="fireButton" class="control-button fire">FIRE</button>
        <button id="nitroButton" class="control-button nitro">NITRO</button>
    </div>

    <!-- Message Modal -->
    <div id="messageModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
            <button id="modalCloseButton">OK</button>
        </div>
    </div>

    <script>
        // Global variables for Firebase (mandatory even if not fully used)
        // These are provided by the Canvas environment at runtime.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Game Constants
        const CANVAS_WIDTH = 800; // Base width for game logic
        const CANVAS_HEIGHT = 600; // Base height for game logic
        const PLAYER_SIZE = 40;
        const ENEMY_SIZE = 45;
        const PROJECTILE_SIZE = 8;
        const PLAYER_SPEED = 3;
        const ENEMY_SPEED_BASE = 1.5;
        const PROJECTILE_SPEED = 7;
        const PLAYER_HEALTH_MAX = 100;
        const ENEMY_HEALTH_MAX = 30;
        const FIRE_RATE_PLAYER_BASE = 200; // ms between shots
        const FIRE_RATE_ENEMY = 1000; // ms between enemy shots
        const NITRO_DURATION = 2000; // ms
        const NITRO_COOLDOWN = 5000; // ms
        const NITRO_SPEED_MULTIPLIER = 2.5;
        const ENEMY_SPAWN_INTERVAL_BASE = 3000; // ms
        const MAX_ENEMIES = 5;
        const SCORE_PER_KILL = 100;
        const POWER_UP_SPAWN_INTERVAL = 10000; // ms
        const RAPID_FIRE_DURATION = 5000; // ms
        const CAMERA_SHAKE_DURATION = 150; // ms
        const CAMERA_SHAKE_INTENSITY = 5; // pixels

        // Game State Variables
        let canvas, ctx;
        let player;
        let enemies = [];
        let playerProjectiles = [];
        let enemyProjectiles = [];
        let particles = [];
        let powerUps = [];
        let score = 0;
        let lastPlayerShotTime = 0;
        let lastEnemySpawnTime = 0;
        let lastPowerUpSpawnTime = 0;
        let nitroActive = false;
        let nitroCooldownTimer = 0;
        let rapidFireActive = false;
        let rapidFireTimer = 0;
        let gameRunning = false;
        let animationFrameId;
        let cameraShakeRemaining = 0;
        let cameraShakeOffset = { x: 0, y: 0 };
        let currentEnemySpeed = ENEMY_SPEED_BASE;
        let currentEnemySpawnInterval = ENEMY_SPAWN_INTERVAL_BASE;
        let playerFireRate = FIRE_RATE_PLAYER_BASE;

        // UI Elements (declared globally, assigned in initGame)
        let scoreDisplay;
        let healthBar;
        let fireButton;
        let nitroButton;
        let messageModal;
        let modalTitle;
        let modalMessage;
        let modalCloseButton;
        let loadingScreen;

        // Touch Input States
        let touchStartX = 0;
        let touchStartY = 0;
        let isMoving = false;
        let currentTouchX = 0;
        let currentTouchY = 0;
        let fireButtonPressed = false;
        let nitroButtonPressed = false;

        // Audio Context for sound effects
        let audioContext;

        // Road lines for visual speed
        const roadLines = [];
        const ROAD_LINE_WIDTH = 8;
        const ROAD_LINE_HEIGHT = 40;
        const ROAD_LINE_SPACING = 60;
        const ROAD_EDGE_OFFSET = 150; // Distance from canvas edge to road lines

        // Player Object
        function Player() {
            this.x = CANVAS_WIDTH / 2;
            this.y = CANVAS_HEIGHT - PLAYER_SIZE * 2;
            this.width = PLAYER_SIZE;
            this.height = PLAYER_SIZE;
            this.color = '#00ffff'; // Cyan
            this.health = PLAYER_HEALTH_MAX;
            this.rotation = 0; // In radians
            this.speed = PLAYER_SPEED;
            this.isDrifting = false; // Not implemented yet, but for future use
        }

        Player.prototype.draw = function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#4a4a6a';
            ctx.beginPath();
            ctx.roundRect(-this.width / 4, -this.height / 2 + 5, this.width / 2, this.height / 3, 4);
            ctx.fill();

            // Front lights
            ctx.fillStyle = '#ffff00'; // Yellow
            ctx.beginPath();
            ctx.roundRect(this.width / 2 - 5, -this.height / 2 + 5, 5, 5, 2);
            ctx.roundRect(-this.width / 2, -this.height / 2 + 5, 5, 5, 2);
            ctx.fill();

            // Nitro Exhaust (visual only, when active)
            if (nitroActive) {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.7)'; // Orange glow
                ctx.beginPath();
                ctx.moveTo(-this.width / 4, this.height / 2);
                ctx.lineTo(-this.width / 6, this.height / 2 + 15);
                ctx.lineTo(this.width / 6, this.height / 2 + 15);
                ctx.lineTo(this.width / 4, this.height / 2);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        };

        Player.prototype.takeDamage = function(amount) {
            this.health -= amount;
            if (this.health < 0) this.health = 0;
            updateHealthBar();
            triggerCameraShake(CAMERA_SHAKE_INTENSITY, CAMERA_SHAKE_DURATION);
            if (this.health === 0) {
                gameOver();
            }
        };

        Player.prototype.heal = function(amount) {
            this.health += amount;
            if (this.health > PLAYER_HEALTH_MAX) this.health = PLAYER_HEALTH_MAX;
            updateHealthBar();
        };

        // Enemy Object
        function Enemy(x, y) {
            this.x = x;
            this.y = y;
            this.width = ENEMY_SIZE;
            this.height = ENEMY_SIZE;
            this.color = '#dc3545'; // Red
            this.health = ENEMY_HEALTH_MAX;
            this.speed = currentEnemySpeed; // Use dynamically adjusted speed
            this.rotation = 0; // Will point towards player
            this.lastShotTime = Date.now();
        }

        Enemy.prototype.draw = function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
            ctx.fill();

            // Turret (simple square)
            ctx.fillStyle = '#8b0000'; // Dark red
            ctx.beginPath();
            ctx.roundRect(-this.width / 6, -this.height / 2 - 5, this.width / 3, 10, 2);
            ctx.fill();

            ctx.restore();
        };

        Enemy.prototype.update = function() {
            // Simple AI: move towards player and shoot
            const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
            this.rotation = angleToPlayer + Math.PI / 2; // Adjust for top-down car orientation

            this.x += Math.cos(angleToPlayer) * this.speed;
            this.y += Math.sin(angleToPlayer) * this.speed;

            // Keep enemy within canvas bounds
            this.x = Math.max(this.width / 2, Math.min(CANVAS_WIDTH - this.width / 2, this.x));
            this.y = Math.max(this.height / 2, Math.min(CANVAS_HEIGHT - this.height / 2, this.y));

            // Shoot at player
            if (Date.now() - this.lastShotTime > FIRE_RATE_ENEMY) {
                this.shoot();
                this.lastShotTime = Date.now();
            }
        };

        Enemy.prototype.shoot = function() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            enemyProjectiles.push(new Projectile(this.x, this.y, angle, '#ff00ff', true)); // Magenta for enemy projectiles
        };

        Enemy.prototype.takeDamage = function(amount) {
            this.health -= amount;
            if (this.health < 0) this.health = 0;
        };

        // Projectile Object
        function Projectile(x, y, angle, color, isEnemy) {
            this.x = x;
            this.y = y;
            this.size = PROJECTILE_SIZE;
            this.speed = PROJECTILE_SPEED;
            this.angle = angle;
            this.color = color;
            this.isEnemy = isEnemy;
        }

        Projectile.prototype.draw = function() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
        };

        Projectile.prototype.update = function() {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
        };

        // Particle Object (for explosions, nitro)
        function Particle(x, y, color, size, velocityX, velocityY, lifespan) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = size;
            this.velocityX = velocityX;
            this.velocityY = velocityY;
            this.lifespan = lifespan; // in frames
            this.currentLifespan = lifespan;
        }

        Particle.prototype.draw = function() {
            ctx.globalAlpha = this.currentLifespan / this.lifespan;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1; // Reset alpha
        };

        Particle.prototype.update = function() {
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.currentLifespan--;
        };

        // PowerUp Object
        function PowerUp(x, y, type) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.type = type; // 'health' or 'rapid_fire'
            this.color = type === 'health' ? '#28a745' : '#007bff'; // Green for health, blue for rapid fire
            this.speed = 1; // Scrolls down slowly
        }

        PowerUp.prototype.draw = function() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size, 5);
            ctx.fill();
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);

            // Draw symbol
            ctx.fillStyle = '#ffffff';
            if (this.type === 'health') {
                ctx.font = 'bold 20px Inter';
                ctx.fillText('+', this.x - 7, this.y + 7);
            } else { // rapid_fire
                ctx.font = 'bold 20px Inter';
                ctx.fillText('âš¡', this.x - 10, this.y + 8); // Lightning bolt emoji
            }
        };

        PowerUp.prototype.update = function() {
            this.y += this.speed;
        };

        // Initialize Game
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Assign UI elements here to ensure they are loaded
            scoreDisplay = document.getElementById('scoreDisplay');
            healthBar = document.getElementById('healthBar');
            fireButton = document.getElementById('fireButton');
            nitroButton = document.getElementById('nitroButton');
            messageModal = document.getElementById('messageModal');
            modalTitle = document.getElementById('modalTitle');
            modalMessage = document.getElementById('modalMessage');
            modalCloseButton = document.getElementById('modalCloseButton');
            loadingScreen = document.getElementById('loadingScreen');

            // Initialize AudioContext
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Set canvas dimensions dynamically based on CSS max-width/height
            // We'll use a fixed internal resolution for game logic and scale the canvas via CSS
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            player = new Player();
            score = 0;
            enemies = [];
            playerProjectiles = [];
            enemyProjectiles = [];
            particles = [];
            powerUps = [];
            nitroActive = false;
            nitroCooldownTimer = 0;
            rapidFireActive = false;
            rapidFireTimer = 0;
            lastPlayerShotTime = 0;
            lastEnemySpawnTime = Date.now();
            lastPowerUpSpawnTime = Date.now();
            cameraShakeRemaining = 0;
            cameraShakeOffset = { x: 0, y: 0 };
            currentEnemySpeed = ENEMY_SPEED_BASE;
            currentEnemySpawnInterval = ENEMY_SPAWN_INTERVAL_BASE;
            playerFireRate = FIRE_RATE_PLAYER_BASE;

            // Initialize road lines
            roadLines.length = 0; // Clear existing lines
            for (let i = 0; i < CANVAS_HEIGHT / ROAD_LINE_SPACING + 2; i++) {
                roadLines.push({
                    y: i * ROAD_LINE_SPACING - ROAD_LINE_HEIGHT,
                    leftX: CANVAS_WIDTH / 2 - ROAD_EDGE_OFFSET,
                    rightX: CANVAS_WIDTH / 2 + ROAD_EDGE_OFFSET
                });
            }

            updateScore();
            updateHealthBar();
            gameRunning = true;

            // Hide loading screen
            loadingScreen.style.display = 'none';

            // Attach Event Listeners for Touch Controls and Buttons (Moved here)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling/zooming
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                // Scale touch coordinates to game canvas resolution
                touchStartX = (touch.clientX - rect.left) / rect.width * CANVAS_WIDTH;
                touchStartY = (touch.clientY - rect.top) / rect.height * CANVAS_HEIGHT;
                currentTouchX = touchStartX;
                currentTouchY = touchStartY;
                isMoving = true;
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                currentTouchX = (touch.clientX - rect.left) / rect.width * CANVAS_WIDTH;
                currentTouchY = (touch.clientY - rect.top) / rect.height * CANVAS_HEIGHT;
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                isMoving = false;
            });

            // Button Listeners
            fireButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                fireButtonPressed = true;
                fireButton.classList.add('bg-green-700'); // Visual feedback
            }, { passive: false });
            fireButton.addEventListener('touchend', (e) => {
                fireButtonPressed = false;
                fireButton.classList.remove('bg-green-700');
            });
            // Also add mouse events for testing on desktop
            fireButton.addEventListener('mousedown', () => { fireButtonPressed = true; fireButton.classList.add('bg-green-700'); });
            fireButton.addEventListener('mouseup', () => { fireButtonPressed = false; fireButton.classList.remove('bg-green-700'); });
            fireButton.addEventListener('mouseleave', () => { fireButtonPressed = false; fireButton.classList.remove('bg-green-700'); });


            nitroButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (nitroCooldownTimer <= 0) {
                    nitroActive = true;
                    nitroButton.classList.add('bg-orange-700');
                    playSound('nitro');
                    triggerCameraShake(CAMERA_SHAKE_INTENSITY * 1.5, NITRO_DURATION);
                    setTimeout(() => {
                        nitroActive = false;
                        nitroButton.classList.remove('bg-orange-700');
                        nitroButton.classList.add('opacity-50', 'cursor-not-allowed');
                        nitroButton.disabled = true;
                        nitroCooldownTimer = NITRO_COOLDOWN;
                    }, NITRO_DURATION);
                }
            }, { passive: false });
            // Also add mouse events for testing on desktop
            nitroButton.addEventListener('mousedown', () => {
                if (nitroCooldownTimer <= 0) {
                    nitroActive = true;
                    nitroButton.classList.add('bg-orange-700');
                    playSound('nitro');
                    triggerCameraShake(CAMERA_SHAKE_INTENSITY * 1.5, NITRO_DURATION);
                    setTimeout(() => {
                        nitroActive = false;
                        nitroButton.classList.remove('bg-orange-700');
                        nitroButton.classList.add('opacity-50', 'cursor-not-allowed');
                        nitroButton.disabled = true;
                        nitroCooldownTimer = NITRO_COOLDOWN;
                    }, NITRO_DURATION);
                }
            });


            // Start game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Game Loop
        function gameLoop() {
            if (!gameRunning) {
                return;
            }

            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Update Game State
        function update() {
            // Update camera shake
            if (cameraShakeRemaining > 0) {
                cameraShakeOffset.x = (Math.random() * 2 - 1) * cameraShakeRemaining / CAMERA_SHAKE_DURATION * CAMERA_SHAKE_INTENSITY;
                cameraShakeOffset.y = (Math.random() * 2 - 1) * cameraShakeRemaining / CAMERA_SHAKE_DURATION * CAMERA_SHAKE_INTENSITY;
                cameraShakeRemaining -= (1000 / 60); // Decrement by frame time
            } else {
                cameraShakeOffset.x = 0;
                cameraShakeOffset.y = 0;
            }

            // Player movement based on touch
            if (isMoving) {
                const dx = currentTouchX - player.x;
                const dy = currentTouchY - player.y;
                const angle = Math.atan2(dy, dx);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) { // Only move if target is far enough
                    let currentSpeed = player.speed;
                    if (nitroActive) {
                        currentSpeed *= NITRO_SPEED_MULTIPLIER;
                    }
                    player.x += Math.cos(angle) * currentSpeed;
                    player.y += Math.sin(angle) * currentSpeed;

                    // Smooth rotation towards movement direction
                    const targetRotation = angle + Math.PI / 2;
                    let diff = targetRotation - player.rotation;
                    // Normalize angle difference to be within -PI to PI
                    if (diff > Math.PI) diff -= (2 * Math.PI);
                    if (diff < -Math.PI) diff += (2 * Math.PI);
                    player.rotation += diff * 0.1; // Lerp factor
                }
            }

            // Keep player within canvas bounds
            player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT - player.height / 2, player.y));

            // Player shooting
            if (fireButtonPressed && Date.now() - lastPlayerShotTime > playerFireRate) {
                playerProjectiles.push(new Projectile(player.x, player.y - player.height / 2, -Math.PI / 2, '#00ffff', false)); // Shoot upwards
                playSound('shoot');
                lastPlayerShotTime = Date.now();
            }

            // Update rapid fire timer
            if (rapidFireActive) {
                rapidFireTimer -= (1000 / 60);
                if (rapidFireTimer <= 0) {
                    rapidFireActive = false;
                    playerFireRate = FIRE_RATE_PLAYER_BASE; // Reset fire rate
                }
            }

            // Update projectiles
            playerProjectiles = playerProjectiles.filter(p => {
                p.update();
                return p.y > 0 && p.y < CANVAS_HEIGHT && p.x > -p.size && p.x < CANVAS_WIDTH + p.size;
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.update();
                return p.y > 0 && p.y < CANVAS_HEIGHT && p.x > -p.size && p.x < CANVAS_WIDTH + p.size;
            });

            // Update enemies and difficulty scaling
            if (Date.now() - lastEnemySpawnTime > currentEnemySpawnInterval && enemies.length < MAX_ENEMIES) {
                spawnEnemy();
                lastEnemySpawnTime = Date.now();
            }
            enemies.forEach(enemy => enemy.update());

            // Update power-ups
            if (Date.now() - lastPowerUpSpawnTime > POWER_UP_SPAWN_INTERVAL) {
                spawnPowerUp();
                lastPowerUpSpawnTime = Date.now();
            }
            powerUps = powerUps.filter(p => {
                p.update();
                return p.y < CANVAS_HEIGHT + p.size; // Remove once off screen
            });

            // Update particles
            particles = particles.filter(p => p.currentLifespan > 0);
            particles.forEach(p => p.update());

            // Update road lines
            const roadScrollSpeed = (player.speed + currentEnemySpeed) * 0.5; // Simulate relative speed
            roadLines.forEach(line => {
                line.y += roadScrollSpeed;
                if (line.y > CANVAS_HEIGHT + ROAD_LINE_HEIGHT / 2) {
                    line.y = -ROAD_LINE_SPACING + ROAD_LINE_HEIGHT / 2;
                }
            });

            // Collision Detection
            // Player Projectile vs Enemy
            playerProjectiles.forEach((p, pIdx) => {
                enemies.forEach((e, eIdx) => {
                    if (checkCollision(p, e)) {
                        e.takeDamage(10); // Damage amount
                        playerProjectiles.splice(pIdx, 1); // Remove projectile
                        if (e.health <= 0) {
                            enemies.splice(eIdx, 1); // Remove enemy
                            score += SCORE_PER_KILL;
                            updateScore();
                            createExplosion(e.x, e.y, e.color);
                            playSound('explosion');
                            // Adjust difficulty
                            currentEnemySpeed = ENEMY_SPEED_BASE + Math.floor(score / 500) * 0.2;
                            currentEnemySpawnInterval = Math.max(1000, ENEMY_SPAWN_INTERVAL_BASE - Math.floor(score / 500) * 200);
                        } else {
                            createImpactParticles(p.x, p.y, p.color);
                        }
                    }
                });
            });

            // Enemy Projectile vs Player
            enemyProjectiles.forEach((p, pIdx) => {
                if (checkCollision(p, player)) {
                    player.takeDamage(15); // Damage amount
                    enemyProjectiles.splice(pIdx, 1); // Remove projectile
                    createImpactParticles(p.x, p.y, p.color);
                    playSound('hit');
                }
            });

            // Player vs Enemy (ramming)
            enemies.forEach((e, eIdx) => {
                if (checkCollision(player, e)) {
                    player.takeDamage(5); // Ramming damage to player
                    e.takeDamage(20); // Ramming damage to enemy
                    createImpactParticles(player.x, player.y, '#ffffff'); // White impact
                    playSound('hit');
                    if (e.health <= 0) {
                        enemies.splice(eIdx, 1);
                        score += SCORE_PER_KILL;
                        updateScore();
                        createExplosion(e.x, e.y, e.color);
                        playSound('explosion');
                        // Adjust difficulty
                        currentEnemySpeed = ENEMY_SPEED_BASE + Math.floor(score / 500) * 0.2;
                        currentEnemySpawnInterval = Math.max(1000, ENEMY_SPAWN_INTERVAL_BASE - Math.floor(score / 500) * 200);
                    }
                }
            });

            // Player vs PowerUp
            powerUps.forEach((pu, puIdx) => {
                if (checkCollision(player, pu)) {
                    if (pu.type === 'health') {
                        player.heal(30); // Heal amount
                    } else if (pu.type === 'rapid_fire') {
                        rapidFireActive = true;
                        rapidFireTimer = RAPID_FIRE_DURATION;
                        playerFireRate = FIRE_RATE_PLAYER_BASE / 2; // Half fire rate
                    }
                    powerUps.splice(puIdx, 1); // Remove power-up
                    playSound('powerup');
                }
            });


            // Nitro cooldown
            if (nitroCooldownTimer > 0) {
                nitroCooldownTimer -= (1000 / 60); // Decrement by frame time (approx 16.67ms)
                if (nitroCooldownTimer <= 0) {
                    nitroButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    nitroButton.disabled = false;
                }
            }
        }

        // Draw Game Elements
        function draw() {
            // Apply camera shake offset
            ctx.save();
            ctx.translate(cameraShakeOffset.x, cameraShakeOffset.y);

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Clear canvas

            // Draw game background (optional, can be textured)
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw road lines
            ctx.fillStyle = '#4a4a6a'; // Grey for road lines
            roadLines.forEach(line => {
                ctx.fillRect(line.leftX, line.y, ROAD_LINE_WIDTH, ROAD_LINE_HEIGHT);
                ctx.fillRect(line.rightX - ROAD_LINE_WIDTH, line.y, ROAD_LINE_WIDTH, ROAD_LINE_HEIGHT);
            });

            // Draw player
            player.draw();

            // Draw enemies
            enemies.forEach(enemy => enemy.draw());

            // Draw projectiles
            playerProjectiles.forEach(p => p.draw());
            enemyProjectiles.forEach(p => p.draw());

            // Draw power-ups
            powerUps.forEach(pu => pu.draw());

            // Draw particles
            particles.forEach(p => p.draw());

            ctx.restore(); // Restore context to remove camera shake
        }

        // Helper: Check for AABB collision
        function checkCollision(obj1, obj2) {
            const obj1HalfWidth = obj1.width / 2 || obj1.size / 2;
            const obj1HalfHeight = obj1.height / 2 || obj1.size / 2;
            const obj2HalfWidth = obj2.width / 2 || obj2.size / 2;
            const obj2HalfHeight = obj2.height / 2 || obj2.size / 2;

            return obj1.x < obj2.x + obj2HalfWidth &&
                   obj1.x + obj1HalfWidth > obj2.x &&
                   obj1.y < obj2.y + obj2HalfHeight &&
                   obj1.y + obj1HalfHeight > obj2.y;
        }

        // Spawn a new enemy
        function spawnEnemy() {
            const x = Math.random() * (CANVAS_WIDTH - ENEMY_SIZE) + ENEMY_SIZE / 2;
            const y = Math.random() * (CANVAS_HEIGHT / 4); // Spawn in top quarter
            enemies.push(new Enemy(x, y));
        }

        // Spawn a new power-up
        function spawnPowerUp() {
            const x = Math.random() * (CANVAS_WIDTH - 60) + 30; // Random X, avoid edges
            const y = -30; // Spawn above canvas
            const type = Math.random() < 0.6 ? 'health' : 'rapid_fire'; // 60% health, 40% rapid fire
            powerUps.push(new PowerUp(x, y, type));
        }

        // Create explosion particles
        function createExplosion(x, y, baseColor) {
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2; // More varied speed
                const size = Math.random() * 6 + 4; // Larger, more varied size
                const lifespan = Math.random() * 40 + 30; // Longer lifespan
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                particles.push(new Particle(x, y, baseColor, size, velocityX, velocityY, lifespan));
            }
        }

        // Create impact particles
        function createImpactParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const size = Math.random() * 4 + 2;
                const lifespan = Math.random() * 20 + 15;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                particles.push(new Particle(x, y, color, size, velocityX, velocityY, lifespan));
            }
        }

        // Camera Shake
        function triggerCameraShake(intensity, duration) {
            cameraShakeRemaining = duration;
        }

        // Sound Playback
        function playSound(type) {
            if (!audioContext) return;

            let oscillator;
            let gainNode;

            switch (type) {
                case 'shoot':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'explosion':
                    const bufferSize = audioContext.sampleRate * 0.5; // 0.5 seconds of noise
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }

                    const noiseSource = audioContext.createBufferSource();
                    noiseSource.buffer = noiseBuffer;
                    gainNode = audioContext.createGain();
                    noiseSource.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    noiseSource.start(audioContext.currentTime);
                    noiseSource.stop(audioContext.currentTime + 0.5);
                    break;
                case 'nitro':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + NITRO_DURATION / 1000);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + NITRO_DURATION / 1000);
                    break;
                case 'hit':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'powerup':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
            }
        }

        // UI Functions
        function updateScore() {
            scoreDisplay.textContent = score;
        }

        function updateHealthBar() {
            const healthPercentage = (player.health / PLAYER_HEALTH_MAX) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            if (healthPercentage < 30) {
                healthBar.classList.add('low');
            } else {
                healthBar.classList.remove('low');
            }
        }

        function showMessage(title, message, onConfirm) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.add('show');
            modalCloseButton.onclick = () => {
                messageModal.classList.remove('show');
                if (onConfirm) {
                    onConfirm();
                }
            };
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            showMessage('Game Over!', `Your score: ${score}`, () => {
                initGame(); // Restart game
            });
        }

        // Initialize Firebase (even if not fully used for game data persistence in this version)
        // This ensures the mandatory global variables are handled.
        // For a full Firebase integration (e.g., high scores), you'd use getFirestore, etc.
        // import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // let app, auth, db;
        // async function initializeFirebase() {
        //     if (Object.keys(firebaseConfig).length > 0) {
        //         app = initializeApp(firebaseConfig);
        //         auth = getAuth(app);
        //         db = getFirestore(app);
        //         try {
        //             if (initialAuthToken) {
        //                 await signInWithCustomToken(auth, initialAuthToken);
        //             } else {
        //                 await signInAnonymously(auth);
        //             }
        //             console.log("Firebase initialized and authenticated.");
        //             // const userId = auth.currentUser?.uid || crypto.randomUUID();
        //             // console.log("User ID:", userId);
        //         } catch (error) {
        //             console.error("Firebase authentication failed:", error);
        //         }
        //     } else {
        //         console.warn("Firebase config not found. Running without Firebase features.");
        //     }
        // }

        // Start the game when the window loads
        window.onload = function() {
            // initializeFirebase().then(() => {
                initGame();
            // });
        };
    </script>
</body>
</html>
