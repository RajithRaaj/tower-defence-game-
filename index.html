<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nitro Drift: Apex Reckoning - Ultimate Edition</title>
    <!-- Tailwind CSS for basic UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark blue background */
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            background-color: #0f0f1a; /* Even darker background for game area */
            border: 4px solid #4a4a6a;
            border-radius: 12px;
            display: block;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            width: 100vw; /* Make canvas fill viewport width */
            height: calc(100vh - 80px); /* Adjust height to leave space for UI if needed, or 100vh */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), 0 0 40px rgba(0, 200, 255, 0.2);
        }
        .game-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90vw;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff; /* Cyan */
            background-color: rgba(15, 15, 26, 0.8);
            border-radius: 10px;
            z-index: 500;
        }
        .health-bar-container {
            width: 150px;
            height: 20px;
            background-color: #4a4a6a;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #00ffff;
        }
        .health-bar {
            height: 100%;
            background-color: #28a745; /* Green */
            width: 100%; /* Default to full */
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
        }
        .health-bar.low {
            background-color: #dc3545; /* Red */
        }

        /* Main Menu / Game Over Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            max-width: 90vw;
            width: 500px;
            color: #e0e0e0;
            border: 2px solid #00ffff;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        .modal-content button {
            background-color: #007bff;
            color: white;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        }
        .modal-content button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .modal-content button:active {
            transform: scale(0.98);
        }

        .modal-section {
            background-color: #0f0f1a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #4a4a6a;
            margin-top: 15px;
        }
        .modal-section h3 {
            font-size: 1.5em;
            color: #00ffff;
            margin-bottom: 10px;
        }
        .modal-section input {
            background-color: #2a2a4a;
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 8px;
            color: #e0e0e0;
            width: calc(100% - 20px);
            margin-bottom: 10px;
        }
        .modal-section .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        .modal-section .upgrade-item span {
            font-size: 1em;
        }
        .modal-section .upgrade-item button {
            padding: 8px 15px;
            font-size: 0.9em;
            border-radius: 20px;
            box-shadow: none;
        }
        .modal-section .upgrade-item button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            color: #00ffff;
            font-size: 2em;
            font-weight: bold;
        }
        .spinner {
            border: 8px solid rgba(0, 255, 255, 0.2);
            border-top: 8px solid #00ffff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .game-info {
                font-size: 1em;
                padding: 8px 15px;
            }
            .health-bar-container {
                width: 100px;
                height: 16px;
            }
            .modal-content {
                padding: 20px;
                gap: 10px;
            }
            .modal-content h2 {
                font-size: 2em;
            }
            .modal-content p {
                font-size: 1em;
            }
            .modal-content button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .modal-section h3 {
                font-size: 1.2em;
            }
            .modal-section input {
                padding: 6px;
            }
            .modal-section .upgrade-item button {
                padding: 6px 10px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="spinner"></div>
        Loading Nitro Drift...
    </div>

    <div class="game-info" id="gameInfo">
        <div>Score: <span id="scoreDisplay">0</span></div>
        <div>Coins: <span id="coinsDisplay">0</span></div>
        <div class="health-bar-container">
            <div id="healthBar" class="health-bar"></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Main Menu / Game Over Modal -->
    <div id="mainMenuModal" class="modal-overlay show">
        <div class="modal-content">
            <h2 id="modalTitle">Nitro Drift: Apex Reckoning</h2>
            <p id="modalMessage">Get ready for high-octane vehicular combat!</p>
            <button id="startGameButton">Start Game</button>

            <div class="modal-section">
                <h3>Upgrades</h3>
                <div class="upgrade-item">
                    <span>Max Health (+50) - Cost: <span id="healthUpgradeCost">100</span> Coins</span>
                    <button id="upgradeHealthButton">Buy</button>
                </div>
                <div class="upgrade-item">
                    <span>Player Speed (+1) - Cost: <span id="speedUpgradeCost">150</span> Coins</span>
                    <button id="upgradeSpeedButton">Buy</button>
                </div>
                <div class="upgrade-item">
                    <span>Fire Rate (x0.8) - Cost: <span id="fireRateUpgradeCost">200</span> Coins</span>
                    <button id="upgradeFireRateButton">Buy</button>
                </div>
                <div class="upgrade-item">
                    <span>Projectile Damage (+5) - Cost: <span id="damageUpgradeCost">250</span> Coins</span>
                    <button id="upgradeDamageButton">Buy</button>
                </div>
                <div class="upgrade-item">
                    <span>Nitro Cooldown (-1s) - Cost: <span id="nitroCooldownUpgradeCost">300</span> Coins</span>
                    <button id="upgradeNitroCooldownButton">Buy</button>
                </div>
            </div>

            <div class="modal-section">
                <h3>Redeem Code</h3>
                <input type="text" id="redeemCodeInput" placeholder="Enter code here">
                <button id="redeemCodeButton">Redeem</button>
            </div>

            <button id="buyCoinsButton">Buy More Coins</button>
        </div>
    </div>

    <script>
        // Global variables for Firebase (mandatory even if not fully used)
        // These are provided by the Canvas environment at runtime.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Game Constants
        const CANVAS_WIDTH_LOGIC = 1200; // Internal logic width, will scale to viewport
        const CANVAS_HEIGHT_LOGIC = 900; // Internal logic height, will scale to viewport
        const PLAYER_SIZE = 60;
        const ENEMY_SIZE_BASE = 50;
        const PROJECTILE_SIZE = 10;
        const PLAYER_SPEED_BASE = 4;
        const ENEMY_SPEED_BASE = 2;
        const PROJECTILE_SPEED = 10;
        const PLAYER_HEALTH_MAX_BASE = 200; // Much higher base health
        const ENEMY_HEALTH_BASE = 40;
        const FIRE_RATE_PLAYER_BASE = 150; // ms between shots (faster default)
        const FIRE_RATE_ENEMY = 1200; // ms between enemy shots (slower for easier play)
        const NITRO_DURATION = 3000; // ms (longer duration)
        const NITRO_COOLDOWN_BASE = 8000; // ms (longer base cooldown)
        const NITRO_SPEED_MULTIPLIER = 2.8;
        const ENEMY_SPAWN_INTERVAL_BASE = 2500; // ms (slightly faster base spawn)
        const MAX_ENEMIES = 7; // More enemies on screen
        const SCORE_PER_KILL = 100;
        const COINS_PER_KILL = 10; // Coins earned per kill
        const POWER_UP_SPAWN_INTERVAL = 5000; // ms (more frequent power-ups)
        const RAPID_FIRE_DURATION = 7000; // ms (longer rapid fire)
        const HEALTH_PACK_HEAL_AMOUNT = 50; // More healing
        const CAMERA_SHAKE_DURATION = 200; // ms
        const CAMERA_SHAKE_INTENSITY = 8; // pixels

        // Upgrade Costs and Effects
        const UPGRADES = {
            health: { cost: 100, effect: 50, currentLevel: 0, maxLevel: 3, description: "Max Health" },
            speed: { cost: 150, effect: 1, currentLevel: 0, maxLevel: 3, description: "Player Speed" },
            fireRate: { cost: 200, effect: 0.1, currentLevel: 0, maxLevel: 3, description: "Fire Rate" },
            damage: { cost: 250, effect: 5, currentLevel: 0, maxLevel: 3, description: "Projectile Damage" },
            nitroCooldown: { cost: 300, effect: 1000, currentLevel: 0, maxLevel: 3, description: "Nitro Cooldown" }
        };

        // Game State Variables
        let canvas, ctx;
        let player;
        let enemies = [];
        let playerProjectiles = [];
        let enemyProjectiles = [];
        let particles = [];
        let powerUps = [];
        let score = 0;
        let coins = 0; // New coins variable
        let lastPlayerShotTime = 0;
        let lastEnemySpawnTime = 0;
        let lastPowerUpSpawnTime = 0;
        let nitroActive = false;
        let nitroCooldownTimer = 0;
        let rapidFireActive = false;
        let rapidFireTimer = 0;
        let gameRunning = false;
        let animationFrameId;
        let cameraShakeRemaining = 0;
        let cameraShakeOffset = { x: 0, y: 0 };
        let currentEnemySpeed = ENEMY_SPEED_BASE;
        let currentEnemySpawnInterval = ENEMY_SPAWN_INTERVAL_BASE;
        let playerFireRate = FIRE_RATE_PLAYER_BASE;
        let playerProjectileDamage = 10; // Base projectile damage
        let playerMaxHealth = PLAYER_HEALTH_MAX_BASE;
        let nitroCooldown = NITRO_COOLDOWN_BASE;

        // UI Elements (declared globally, assigned in initGame)
        let scoreDisplay, coinsDisplay, healthBar;
        let mainMenuModal, modalTitle, modalMessage, startGameButton;
        let redeemCodeInput, redeemCodeButton, buyCoinsButton;
        let loadingScreen;

        // Upgrade buttons and cost displays
        let healthUpgradeCostDisplay, speedUpgradeCostDisplay, fireRateUpgradeCostDisplay, damageUpgradeCostDisplay, nitroCooldownUpgradeCostDisplay;
        let upgradeHealthButton, upgradeSpeedButton, upgradeFireRateButton, upgradeDamageButton, upgradeNitroCooldownButton;

        // Touch Input States
        let touchStartX = 0;
        let touchStartY = 0;
        let isMoving = false;
        let currentTouchX = 0;
        let currentTouchY = 0;
        let playerTouchId = -1; // To track specific touch for movement
        let nitroTouchId = -1; // To track specific touch for nitro

        // Audio Context for sound effects
        let audioContext;

        // Road lines for visual speed
        const roadLines = [];
        const ROAD_LINE_WIDTH = 8;
        const ROAD_LINE_HEIGHT = 40;
        const ROAD_LINE_SPACING = 60;
        const ROAD_EDGE_OFFSET = 150; // Distance from canvas edge to road lines

        // Player Object
        function Player() {
            this.x = CANVAS_WIDTH_LOGIC / 2;
            this.y = CANVAS_HEIGHT_LOGIC - PLAYER_SIZE * 2;
            this.width = PLAYER_SIZE;
            this.height = PLAYER_SIZE;
            this.color = '#00ffff'; // Cyan
            this.health = playerMaxHealth; // Use upgraded max health
            this.rotation = 0; // In radians
            this.speed = PLAYER_SPEED_BASE; // Base speed, will be modified by upgrades
            this.isDrifting = false; // Not implemented yet, but for future use
        }

        Player.prototype.draw = function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#4a4a6a';
            ctx.beginPath();
            ctx.roundRect(-this.width / 4, -this.height / 2 + 5, this.width / 2, this.height / 3, 4);
            ctx.fill();

            // Front lights
            ctx.fillStyle = '#ffff00'; // Yellow
            ctx.beginPath();
            ctx.roundRect(this.width / 2 - 5, -this.height / 2 + 5, 5, 5, 2);
            ctx.roundRect(-this.width / 2, -this.height / 2 + 5, 5, 5, 2);
            ctx.fill();

            // Nitro Exhaust (visual only, when active)
            if (nitroActive) {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.7)'; // Orange glow
                ctx.beginPath();
                ctx.moveTo(-this.width / 4, this.height / 2);
                ctx.lineTo(-this.width / 6, this.height / 2 + 15);
                ctx.lineTo(this.width / 6, this.height / 2 + 15);
                ctx.lineTo(this.width / 4, this.height / 2);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        };

        Player.prototype.takeDamage = function(amount) {
            this.health -= amount;
            if (this.health < 0) this.health = 0;
            updateHealthBar();
            triggerCameraShake(CAMERA_SHAKE_INTENSITY, CAMERA_SHAKE_DURATION);
            if (this.health === 0) {
                gameOver();
            }
        };

        Player.prototype.heal = function(amount) {
            this.health += amount;
            if (this.health > playerMaxHealth) this.health = playerMaxHealth; // Heal up to upgraded max health
            updateHealthBar();
        };

        // Enemy Object
        function Enemy(x, y, type = 'basic') {
            this.x = x;
            this.y = y;
            this.type = type;
            this.width = ENEMY_SIZE_BASE;
            this.height = ENEMY_SIZE_BASE;
            this.color = '#dc3545'; // Red for basic
            this.health = ENEMY_HEALTH_BASE;
            this.speed = currentEnemySpeed; // Use dynamically adjusted speed
            this.rotation = 0; // Will point towards player
            this.lastShotTime = Date.now();

            if (this.type === 'heavy') {
                this.width = ENEMY_SIZE_BASE * 1.2;
                this.height = ENEMY_SIZE_BASE * 1.2;
                this.color = '#8a2be2'; // Blue-violet for heavy
                this.health = ENEMY_HEALTH_BASE * 1.5; // More health
                this.speed = currentEnemySpeed * 0.8; // Slower
            }
        }

        Enemy.prototype.draw = function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
            ctx.fill();

            // Turret (simple square)
            ctx.fillStyle = this.type === 'heavy' ? '#4b0082' : '#8b0000'; // Darker color for heavy
            ctx.beginPath();
            ctx.roundRect(-this.width / 6, -this.height / 2 - 5, this.width / 3, 10, 2);
            ctx.fill();

            ctx.restore();
        };

        Enemy.prototype.update = function() {
            // Simple AI: move towards player and shoot
            const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
            this.rotation = angleToPlayer + Math.PI / 2; // Adjust for top-down car orientation

            this.x += Math.cos(angleToPlayer) * this.speed;
            this.y += Math.sin(angleToPlayer) * this.speed;

            // Keep enemy within canvas bounds
            this.x = Math.max(this.width / 2, Math.min(CANVAS_WIDTH_LOGIC - this.width / 2, this.x));
            this.y = Math.max(this.height / 2, Math.min(CANVAS_HEIGHT_LOGIC - this.height / 2, this.y));

            // Shoot at player
            if (Date.now() - this.lastShotTime > FIRE_RATE_ENEMY) {
                this.shoot();
                this.lastShotTime = Date.now();
            }
        };

        Enemy.prototype.shoot = function() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            enemyProjectiles.push(new Projectile(this.x, this.y, angle, '#ff00ff', true)); // Magenta for enemy projectiles
        };

        Enemy.prototype.takeDamage = function(amount) {
            this.health -= amount;
            if (this.health < 0) this.health = 0;
        };

        // Projectile Object
        function Projectile(x, y, angle, color, isEnemy) {
            this.x = x;
            this.y = y;
            this.size = PROJECTILE_SIZE;
            this.speed = PROJECTILE_SPEED;
            this.angle = angle;
            this.color = color;
            this.isEnemy = isEnemy;
            this.damage = isEnemy ? 10 : playerProjectileDamage; // Player damage is dynamic
        }

        Projectile.prototype.draw = function() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
        };

        Projectile.prototype.update = function() {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
        };

        // Particle Object (for explosions, nitro)
        function Particle(x, y, color, size, velocityX, velocityY, lifespan) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = size;
            this.velocityX = velocityX;
            this.velocityY = velocityY;
            this.lifespan = lifespan; // in frames
            this.currentLifespan = lifespan;
        }

        Particle.prototype.draw = function() {
            ctx.globalAlpha = this.currentLifespan / this.lifespan;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1; // Reset alpha
        };

        Particle.prototype.update = function() {
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.currentLifespan--;
        };

        // PowerUp Object
        function PowerUp(x, y, type) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.type = type; // 'health', 'rapid_fire', 'shield', 'triple_shot'
            this.color = '#ffffff'; // Default white, will be overridden
            this.symbol = ''; // Emoji symbol

            switch (type) {
                case 'health':
                    this.color = '#28a745'; // Green
                    this.symbol = '✚';
                    break;
                case 'rapid_fire':
                    this.color = '#007bff'; // Blue
                    this.symbol = '⚡';
                    break;
                case 'shield':
                    this.color = '#ffc107'; // Yellow
                    this.symbol = '🛡️';
                    break;
                case 'triple_shot':
                    this.color = '#6f42c1'; // Purple
                    this.symbol = '✖️3';
                    break;
            }
            this.speed = 1.5; // Scrolls down slowly
        }

        PowerUp.prototype.draw = function() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size, 5);
            ctx.fill();
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);

            // Draw symbol
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.symbol, this.x, this.y + 2); // Adjust Y for better centering
        };

        PowerUp.prototype.update = function() {
            this.y += this.speed;
        };

        // Game Initialization
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Assign UI elements here to ensure they are loaded
            scoreDisplay = document.getElementById('scoreDisplay');
            coinsDisplay = document.getElementById('coinsDisplay');
            healthBar = document.getElementById('healthBar');
            mainMenuModal = document.getElementById('mainMenuModal');
            modalTitle = document.getElementById('modalTitle');
            modalMessage = document.getElementById('modalMessage');
            startGameButton = document.getElementById('startGameButton');
            redeemCodeInput = document.getElementById('redeemCodeInput');
            redeemCodeButton = document.getElementById('redeemCodeButton');
            buyCoinsButton = document.getElementById('buyCoinsButton');
            loadingScreen = document.getElementById('loadingScreen');

            // Upgrade buttons and cost displays
            healthUpgradeCostDisplay = document.getElementById('healthUpgradeCost');
            speedUpgradeCostDisplay = document.getElementById('speedUpgradeCost');
            fireRateUpgradeCostDisplay = document.getElementById('fireRateUpgradeCost');
            damageUpgradeCostDisplay = document.getElementById('damageUpgradeCost');
            nitroCooldownUpgradeCostDisplay = document.getElementById('nitroCooldownUpgradeCost');

            upgradeHealthButton = document.getElementById('upgradeHealthButton');
            upgradeSpeedButton = document.getElementById('upgradeSpeedButton');
            upgradeFireRateButton = document.getElementById('upgradeFireRateButton');
            upgradeDamageButton = document.getElementById('upgradeDamageButton');
            upgradeNitroCooldownButton = document.getElementById('upgradeNitroCooldownButton');

            // Initialize AudioContext
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Set canvas dimensions dynamically based on CSS viewport size
            // We'll use a fixed internal resolution for game logic and scale the drawing
            canvas.width = CANVAS_WIDTH_LOGIC;
            canvas.height = CANVAS_HEIGHT_LOGIC;

            // Initial game state setup
            player = new Player();
            score = 0;
            coins = 0;
            enemies = [];
            playerProjectiles = [];
            enemyProjectiles = [];
            particles = [];
            powerUps = [];
            nitroActive = false;
            nitroCooldownTimer = 0;
            rapidFireActive = false;
            rapidFireTimer = 0;
            lastPlayerShotTime = 0;
            lastEnemySpawnTime = Date.now();
            lastPowerUpSpawnTime = Date.now();
            cameraShakeRemaining = 0;
            cameraShakeOffset = { x: 0, y: 0 };

            // Reset difficulty and player stats to base (or upgraded if loaded from persistence)
            currentEnemySpeed = ENEMY_SPEED_BASE;
            currentEnemySpawnInterval = ENEMY_SPAWN_INTERVAL_BASE;
            playerFireRate = FIRE_RATE_PLAYER_BASE;
            playerProjectileDamage = 10;
            playerMaxHealth = PLAYER_HEALTH_MAX_BASE;
            nitroCooldown = NITRO_COOLDOWN_BASE;

            // Apply upgrades from UPGRADES object (if levels are stored/loaded)
            applyUpgrades();

            // Initialize road lines
            roadLines.length = 0; // Clear existing lines
            for (let i = 0; i < CANVAS_HEIGHT_LOGIC / ROAD_LINE_SPACING + 2; i++) {
                roadLines.push({
                    y: i * ROAD_LINE_SPACING - ROAD_LINE_HEIGHT,
                    leftX: CANVAS_WIDTH_LOGIC / 2 - ROAD_EDGE_OFFSET,
                    rightX: CANVAS_WIDTH_LOGIC / 2 + ROAD_EDGE_OFFSET
                });
            }

            updateScore();
            updateCoins();
            updateHealthBar();
            updateUpgradeUI(); // Update UI for upgrade costs/levels

            // Hide loading screen
            loadingScreen.style.display = 'none';

            // Attach Event Listeners (ensure they are only attached once)
            setupEventListeners();

            // Show main menu initially
            showMainMenu();
        }

        // Setup Event Listeners (called once in initGame)
        function setupEventListeners() {
            // Canvas touch for movement and nitro
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    const rect = canvas.getBoundingClientRect();
                    const touchX = (touch.clientX - rect.left) / rect.width * CANVAS_WIDTH_LOGIC;
                    // Check if touch is on the left half for movement
                    if (touchX < CANVAS_WIDTH_LOGIC / 2 && playerTouchId === -1) {
                        playerTouchId = touch.identifier;
                        currentTouchX = touchX;
                        currentTouchY = (touch.clientY - rect.top) / rect.height * CANVAS_HEIGHT_LOGIC;
                        isMoving = true;
                    }
                    // Check if touch is on the right half for nitro
                    else if (touchX >= CANVAS_WIDTH_LOGIC / 2 && nitroTouchId === -1) {
                        nitroTouchId = touch.identifier;
                        activateNitro();
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === playerTouchId) {
                        const rect = canvas.getBoundingClientRect();
                        currentTouchX = (touch.clientX - rect.left) / rect.width * CANVAS_WIDTH_LOGIC;
                        currentTouchY = (touch.clientY - rect.top) / rect.height * CANVAS_HEIGHT_LOGIC;
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === playerTouchId) {
                        isMoving = false;
                        playerTouchId = -1;
                    }
                    if (touch.identifier === nitroTouchId) {
                        nitroTouchId = -1;
                    }
                }
            });

            // Mouse events for desktop testing (simulating touch)
            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * CANVAS_WIDTH_LOGIC;
                if (mouseX < CANVAS_WIDTH_LOGIC / 2) { // Left half for movement
                    currentTouchX = mouseX;
                    currentTouchY = (e.clientY - rect.top) / rect.height * CANVAS_HEIGHT_LOGIC;
                    isMoving = true;
                } else { // Right half for nitro
                    activateNitro();
                }
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isMoving) {
                    const rect = canvas.getBoundingClientRect();
                    currentTouchX = (e.clientX - rect.left) / rect.width * CANVAS_WIDTH_LOGIC;
                    currentTouchY = (e.clientY - rect.top) / rect.height * CANVAS_HEIGHT_LOGIC;
                }
            });
            canvas.addEventListener('mouseup', () => {
                isMoving = false;
            });
            canvas.addEventListener('mouseleave', () => { // Stop moving if mouse leaves canvas
                isMoving = false;
            });


            // Menu Button Listeners
            startGameButton.onclick = () => {
                mainMenuModal.classList.remove('show');
                startGame();
            };

            redeemCodeButton.onclick = redeemCode;
            buyCoinsButton.onclick = () => {
                window.open('https://tally.so/r/3x7Bl5', '_blank');
            };

            // Upgrade Button Listeners
            upgradeHealthButton.onclick = () => buyUpgrade('health');
            upgradeSpeedButton.onclick = () => buyUpgrade('speed');
            upgradeFireRateButton.onclick = () => buyUpgrade('fireRate');
            upgradeDamageButton.onclick = () => buyUpgrade('damage');
            upgradeNitroCooldownButton.onclick = () => buyUpgrade('nitroCooldown');
        }

        // Start Game Function
        function startGame() {
            gameRunning = true;
            // Reset game state for a new game, but keep upgrades
            player = new Player(); // Re-initialize player with current upgraded stats
            player.health = playerMaxHealth; // Start with full upgraded health
            score = 0;
            enemies = [];
            playerProjectiles = [];
            enemyProjectiles = [];
            particles = [];
            powerUps = [];
            nitroActive = false;
            nitroCooldownTimer = 0;
            rapidFireActive = false;
            rapidFireTimer = 0;
            lastPlayerShotTime = 0;
            lastEnemySpawnTime = Date.now();
            lastPowerUpSpawnTime = Date.now();
            currentEnemySpeed = ENEMY_SPEED_BASE;
            currentEnemySpawnInterval = ENEMY_SPAWN_INTERVAL_BASE;
            updateScore();
            updateCoins();
            updateHealthBar();

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Game Loop
        function gameLoop() {
            if (!gameRunning) {
                return;
            }

            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Update Game State
        function update() {
            // Update camera shake
            if (cameraShakeRemaining > 0) {
                cameraShakeOffset.x = (Math.random() * 2 - 1) * cameraShakeRemaining / CAMERA_SHAKE_DURATION * CAMERA_SHAKE_INTENSITY;
                cameraShakeOffset.y = (Math.random() * 2 - 1) * cameraShakeRemaining / CAMERA_SHAKE_DURATION * CAMERA_SHAKE_INTENSITY;
                cameraShakeRemaining -= (1000 / 60); // Decrement by frame time
            } else {
                cameraShakeOffset.x = 0;
                cameraShakeOffset.y = 0;
            }

            // Player movement based on touch
            if (isMoving) {
                const dx = currentTouchX - player.x;
                const dy = currentTouchY - player.y;
                const angle = Math.atan2(dy, dx);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) { // Only move if target is far enough
                    let currentSpeed = player.speed;
                    if (nitroActive) {
                        currentSpeed *= NITRO_SPEED_MULTIPLIER;
                    }
                    player.x += Math.cos(angle) * currentSpeed;
                    player.y += Math.sin(angle) * currentSpeed;

                    // Smooth rotation towards movement direction
                    const targetRotation = angle + Math.PI / 2;
                    let diff = targetRotation - player.rotation;
                    // Normalize angle difference to be within -PI to PI
                    if (diff > Math.PI) diff -= (2 * Math.PI);
                    if (diff < -Math.PI) diff += (2 * Math.PI);
                    player.rotation += diff * 0.1; // Lerp factor
                }
            }

            // Keep player within canvas bounds
            player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH_LOGIC - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT_LOGIC - player.height / 2, player.y));

            // Player continuous shooting
            if (Date.now() - lastPlayerShotTime > playerFireRate) {
                // Triple shot if active
                if (rapidFireActive && playerFireRate === FIRE_RATE_PLAYER_BASE / 2) { // Only triple shot if rapid fire is the active buff
                    playerProjectiles.push(new Projectile(player.x - 15, player.y - player.height / 2, -Math.PI / 2, '#00ffff', false));
                    playerProjectiles.push(new Projectile(player.x, player.y - player.height / 2, -Math.PI / 2, '#00ffff', false));
                    playerProjectiles.push(new Projectile(player.x + 15, player.y - player.height / 2, -Math.PI / 2, '#00ffff', false));
                } else {
                    playerProjectiles.push(new Projectile(player.x, player.y - player.height / 2, -Math.PI / 2, '#00ffff', false)); // Shoot upwards
                }
                playSound('shoot');
                lastPlayerShotTime = Date.now();
            }

            // Update rapid fire timer
            if (rapidFireActive) {
                rapidFireTimer -= (1000 / 60);
                if (rapidFireTimer <= 0) {
                    rapidFireActive = false;
                    playerFireRate = FIRE_RATE_PLAYER_BASE; // Reset fire rate
                }
            }

            // Update projectiles
            playerProjectiles = playerProjectiles.filter(p => {
                p.update();
                return p.y > -p.size && p.y < CANVAS_HEIGHT_LOGIC + p.size && p.x > -p.size && p.x < CANVAS_WIDTH_LOGIC + p.size;
            });

            enemyProjectiles = enemyProjectiles.filter(p => {
                p.update();
                return p.y > -p.size && p.y < CANVAS_HEIGHT_LOGIC + p.size && p.x > -p.size && p.x < CANVAS_WIDTH_LOGIC + p.size;
            });

            // Update enemies and difficulty scaling
            if (Date.now() - lastEnemySpawnTime > currentEnemySpawnInterval && enemies.length < MAX_ENEMIES) {
                spawnEnemy();
                lastEnemySpawnTime = Date.now();
            }
            enemies.forEach(enemy => enemy.update());

            // Update power-ups
            if (Date.now() - lastPowerUpSpawnTime > POWER_UP_SPAWN_INTERVAL) {
                spawnPowerUp();
                lastPowerUpSpawnTime = Date.now();
            }
            powerUps = powerUps.filter(p => {
                p.update();
                return p.y < CANVAS_HEIGHT_LOGIC + p.size; // Remove once off screen
            });

            // Update particles
            particles = particles.filter(p => p.currentLifespan > 0);
            particles.forEach(p => p.update());

            // Update road lines
            const roadScrollSpeed = (player.speed + currentEnemySpeed) * 0.5; // Simulate relative speed
            roadLines.forEach(line => {
                line.y += roadScrollSpeed;
                if (line.y > CANVAS_HEIGHT_LOGIC + ROAD_LINE_HEIGHT / 2) {
                    line.y = -ROAD_LINE_SPACING + ROAD_LINE_HEIGHT / 2;
                }
            });

            // Collision Detection
            // Player Projectile vs Enemy
            playerProjectiles.forEach((p, pIdx) => {
                enemies.forEach((e, eIdx) => {
                    if (checkCollision(p, e)) {
                        e.takeDamage(p.damage); // Use projectile's damage
                        playerProjectiles.splice(pIdx, 1); // Remove projectile
                        if (e.health <= 0) {
                            enemies.splice(eIdx, 1); // Remove enemy
                            score += SCORE_PER_KILL;
                            coins += COINS_PER_KILL; // Earn coins
                            updateScore();
                            updateCoins();
                            createExplosion(e.x, e.y, e.color);
                            playSound('explosion');
                            // Adjust difficulty (slower scaling for easier play)
                            currentEnemySpeed = ENEMY_SPEED_BASE + Math.floor(score / 1000) * 0.1;
                            currentEnemySpawnInterval = Math.max(1500, ENEMY_SPAWN_INTERVAL_BASE - Math.floor(score / 1000) * 100);
                        } else {
                            createImpactParticles(p.x, p.y, p.color);
                        }
                    }
                });
            });

            // Enemy Projectile vs Player
            enemyProjectiles.forEach((p, pIdx) => {
                if (checkCollision(p, player)) {
                    player.takeDamage(p.damage * 0.5); // Enemy projectiles do less damage
                    enemyProjectiles.splice(pIdx, 1); // Remove projectile
                    createImpactParticles(p.x, p.y, p.color);
                    playSound('hit');
                }
            });

            // Player vs Enemy (ramming)
            enemies.forEach((e, eIdx) => {
                if (checkCollision(player, e)) {
                    player.takeDamage(10); // Ramming damage to player (reduced)
                    e.takeDamage(30); // Ramming damage to enemy (increased)
                    createImpactParticles(player.x, player.y, '#ffffff'); // White impact
                    playSound('hit');
                    if (e.health <= 0) {
                        enemies.splice(eIdx, 1);
                        score += SCORE_PER_KILL;
                        coins += COINS_PER_KILL;
                        updateScore();
                        updateCoins();
                        createExplosion(e.x, e.y, e.color);
                        playSound('explosion');
                        // Adjust difficulty
                        currentEnemySpeed = ENEMY_SPEED_BASE + Math.floor(score / 1000) * 0.1;
                        currentEnemySpawnInterval = Math.max(1500, ENEMY_SPAWN_INTERVAL_BASE - Math.floor(score / 1000) * 100);
                    }
                }
            });

            // Player vs PowerUp
            powerUps.forEach((pu, puIdx) => {
                if (checkCollision(player, pu)) {
                    if (pu.type === 'health') {
                        player.heal(HEALTH_PACK_HEAL_AMOUNT);
                    } else if (pu.type === 'rapid_fire') {
                        rapidFireActive = true;
                        rapidFireTimer = RAPID_FIRE_DURATION;
                        playerFireRate = FIRE_RATE_PLAYER_BASE / 2; // Half fire rate for rapid fire
                    } else if (pu.type === 'shield') {
                        // Implement shield: temporary invincibility or damage reduction
                        // For now, just heal a bit more
                        player.heal(20);
                        showMessage("Shield Acquired!", "Temporary defense boost!");
                    } else if (pu.type === 'triple_shot') {
                        // Triple shot is now integrated with rapid_fire for simplicity
                        // If rapid_fire is active, it automatically becomes triple shot
                        rapidFireActive = true;
                        rapidFireTimer = RAPID_FIRE_DURATION;
                        playerFireRate = FIRE_RATE_PLAYER_BASE / 2;
                        showMessage("Triple Shot!", "Unleash a barrage of projectiles!");
                    }
                    powerUps.splice(puIdx, 1); // Remove power-up
                    playSound('powerup');
                }
            });

            // Nitro cooldown
            if (nitroCooldownTimer > 0) {
                nitroCooldownTimer -= (1000 / 60); // Decrement by frame time (approx 16.67ms)
                if (nitroCooldownTimer <= 0) {
                    // No button to enable, but reset state
                }
            }
        }

        // Draw Game Elements
        function draw() {
            // Apply camera shake offset
            ctx.save();
            ctx.translate(cameraShakeOffset.x, cameraShakeOffset.y);

            ctx.clearRect(0, 0, CANVAS_WIDTH_LOGIC, CANVAS_HEIGHT_LOGIC); // Clear canvas

            // Draw game background (optional, can be textured)
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, CANVAS_WIDTH_LOGIC, CANVAS_HEIGHT_LOGIC);

            // Draw road lines
            ctx.fillStyle = '#4a4a6a'; // Grey for road lines
            roadLines.forEach(line => {
                ctx.fillRect(line.leftX, line.y, ROAD_LINE_WIDTH, ROAD_LINE_HEIGHT);
                ctx.fillRect(line.rightX - ROAD_LINE_WIDTH, line.y, ROAD_LINE_WIDTH, ROAD_LINE_HEIGHT);
            });

            // Draw player
            player.draw();

            // Draw enemies
            enemies.forEach(enemy => enemy.draw());

            // Draw projectiles
            playerProjectiles.forEach(p => p.draw());
            enemyProjectiles.forEach(p => p.draw());

            // Draw power-ups
            powerUps.forEach(pu => pu.draw());

            // Draw particles
            particles.forEach(p => p.draw());

            ctx.restore(); // Restore context to remove camera shake
        }

        // Helper: Check for AABB collision
        function checkCollision(obj1, obj2) {
            const obj1HalfWidth = obj1.width / 2 || obj1.size / 2;
            const obj1HalfHeight = obj1.height / 2 || obj1.size / 2;
            const obj2HalfWidth = obj2.width / 2 || obj2.size / 2;
            const obj2HalfHeight = obj2.height / 2 || obj2.size / 2;

            return obj1.x < obj2.x + obj2HalfWidth &&
                   obj1.x + obj1HalfWidth > obj2.x &&
                   obj1.y < obj2.y + obj2HalfHeight &&
                   obj1.y + obj1HalfHeight > obj2.y;
        }

        // Spawn a new enemy
        function spawnEnemy() {
            const x = Math.random() * (CANVAS_WIDTH_LOGIC - ENEMY_SIZE_BASE) + ENEMY_SIZE_BASE / 2;
            const y = Math.random() * (CANVAS_HEIGHT_LOGIC / 4); // Spawn in top quarter
            const enemyType = Math.random() < 0.3 ? 'heavy' : 'basic'; // 30% chance for heavy enemy
            enemies.push(new Enemy(x, y, enemyType));
        }

        // Spawn a new power-up
        function spawnPowerUp() {
            const x = Math.random() * (CANVAS_WIDTH_LOGIC - 60) + 30; // Random X, avoid edges
            const y = -30; // Spawn above canvas
            const types = ['health', 'rapid_fire', 'shield', 'triple_shot'];
            const type = types[Math.floor(Math.random() * types.length)];
            powerUps.push(new PowerUp(x, y, type));
        }

        // Create explosion particles
        function createExplosion(x, y, baseColor) {
            for (let i = 0; i < 60; i++) { // More particles
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 7 + 3; // More varied speed
                const size = Math.random() * 8 + 5; // Larger, more varied size
                const lifespan = Math.random() * 50 + 40; // Longer lifespan
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                particles.push(new Particle(x, y, baseColor, size, velocityX, velocityY, lifespan));
            }
        }

        // Create impact particles
        function createImpactParticles(x, y, color) {
            for (let i = 0; i < 20; i++) { // More particles
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1.5;
                const size = Math.random() * 5 + 3;
                const lifespan = Math.random() * 25 + 20;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                particles.push(new Particle(x, y, color, size, velocityX, velocityY, lifespan));
            }
        }

        // Camera Shake
        function triggerCameraShake(intensity, duration) {
            cameraShakeRemaining = duration;
        }

        // Sound Playback
        function playSound(type) {
            if (!audioContext) return;

            let oscillator;
            let gainNode;

            switch (type) {
                case 'shoot':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08); // Shorter, sharper
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.08);
                    break;
                case 'explosion':
                    const bufferSize = audioContext.sampleRate * 0.6; // Longer noise
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }

                    const noiseSource = audioContext.createBufferSource();
                    noiseSource.buffer = noiseBuffer;
                    gainNode = audioContext.createGain();
                    noiseSource.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    gainNode.gain.setValueAtTime(0.7, audioContext.currentTime); // Louder
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.6);
                    noiseSource.start(audioContext.currentTime);
                    noiseSource.stop(audioContext.currentTime + 0.6);
                    break;
                case 'nitro':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(250, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(1000, audioContext.currentTime + 0.7); // Higher pitch change
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + NITRO_DURATION / 1000);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + NITRO_DURATION / 1000);
                    break;
                case 'hit':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(120, audioContext.currentTime); // Lower pitch
                    gainNode.gain.setValueAtTime(0.35, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.07);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.07);
                    break;
                case 'powerup':
                    oscillator = audioContext.createOscillator();
                    gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(1200, audioContext.currentTime + 0.15); // Higher, faster chime
                    gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.25);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.25);
                    break;
            }
        }

        // UI Functions
        function updateScore() {
            scoreDisplay.textContent = score;
        }

        function updateCoins() {
            coinsDisplay.textContent = coins;
            updateUpgradeUI(); // Update upgrade button states when coins change
        }

        function updateHealthBar() {
            const healthPercentage = (player.health / playerMaxHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            if (healthPercentage < 30) {
                healthBar.classList.add('low');
            } else {
                healthBar.classList.remove('low');
            }
        }

        function showMessage(title, message, onConfirm) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            // Hide other sections for a simple message
            document.querySelectorAll('.modal-section').forEach(section => section.style.display = 'none');
            startGameButton.style.display = 'none';
            buyCoinsButton.style.display = 'none';

            mainMenuModal.classList.add('show');
            modalCloseButton.onclick = () => {
                mainMenuModal.classList.remove('show');
                // Restore sections if needed for game over
                document.querySelectorAll('.modal-section').forEach(section => section.style.display = 'block');
                startGameButton.style.display = 'block';
                buyCoinsButton.style.display = 'block';
                if (onConfirm) {
                    onConfirm();
                }
            };
        }

        function showMainMenu() {
            gameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            modalTitle.textContent = "Nitro Drift: Apex Reckoning";
            modalMessage.textContent = "Get ready for high-octane vehicular combat!";
            document.querySelectorAll('.modal-section').forEach(section => section.style.display = 'block');
            startGameButton.style.display = 'block';
            buyCoinsButton.style.display = 'block';
            mainMenuModal.classList.add('show');
            updateUpgradeUI(); // Ensure upgrade UI is fresh
        }

        function gameOver() {
            gameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            modalTitle.textContent = "Game Over!";
            modalMessage.textContent = `Your Score: ${score} | Coins Earned: ${coins}`;
            document.querySelectorAll('.modal-section').forEach(section => section.style.display = 'block');
            startGameButton.style.display = 'block';
            buyCoinsButton.style.display = 'block';
            mainMenuModal.classList.add('show');
            updateUpgradeUI(); // Ensure upgrade UI is fresh
        }

        // Upgrade System Functions
        function updateUpgradeUI() {
            for (const key in UPGRADES) {
                const upgrade = UPGRADES[key];
                const costDisplay = document.getElementById(`${key}UpgradeCost`);
                const buyButton = document.getElementById(`upgrade${key.charAt(0).toUpperCase() + key.slice(1)}Button`);

                if (upgrade.currentLevel >= upgrade.maxLevel) {
                    costDisplay.textContent = "MAX";
                    buyButton.disabled = true;
                    buyButton.textContent = "MAXED";
                    buyButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    const currentCost = upgrade.cost * (upgrade.currentLevel + 1); // Cost increases with level
                    costDisplay.textContent = currentCost;
                    buyButton.disabled = coins < currentCost;
                    buyButton.textContent = "Buy";
                    if (coins < currentCost) {
                        buyButton.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        buyButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }
            }
        }

        function buyUpgrade(upgradeType) {
            const upgrade = UPGRADES[upgradeType];
            const currentCost = upgrade.cost * (upgrade.currentLevel + 1);

            if (coins >= currentCost && upgrade.currentLevel < upgrade.maxLevel) {
                coins -= currentCost;
                upgrade.currentLevel++;
                applyUpgrades(); // Apply the new upgrade level
                updateCoins();
                updateUpgradeUI();
                playSound('powerup'); // Use powerup sound for buying upgrade
                showMessage("Upgrade Purchased!", `${upgrade.description} upgraded to level ${upgrade.currentLevel}!`);
            } else if (upgrade.currentLevel >= upgrade.maxLevel) {
                showMessage("Upgrade Maxed!", `${upgrade.description} is already at max level.`);
            } else {
                showMessage("Not Enough Coins!", `You need ${currentCost - coins} more coins for this upgrade.`);
            }
        }

        function applyUpgrades() {
            // Reset to base values before applying upgrades to avoid compounding errors
            playerMaxHealth = PLAYER_HEALTH_MAX_BASE;
            player.speed = PLAYER_SPEED_BASE;
            playerFireRate = FIRE_RATE_PLAYER_BASE;
            playerProjectileDamage = 10;
            nitroCooldown = NITRO_COOLDOWN_BASE;

            // Apply effects based on current upgrade levels
            playerMaxHealth += UPGRADES.health.currentLevel * UPGRADES.health.effect;
            player.speed += UPGRADES.speed.currentLevel * UPGRADES.speed.effect;
            playerFireRate = FIRE_RATE_PLAYER_BASE * Math.pow((1 - UPGRADES.fireRate.effect), UPGRADES.fireRate.currentLevel);
            playerProjectileDamage += UPGRADES.damage.currentLevel * UPGRADES.damage.effect;
            nitroCooldown -= UPGRADES.nitroCooldown.currentLevel * UPGRADES.nitroCooldown.effect;
            if (nitroCooldown < 1000) nitroCooldown = 1000; // Minimum cooldown

            // Ensure player health scales with max health if already playing
            if (player) {
                player.health = Math.min(player.health, playerMaxHealth);
                updateHealthBar();
            }
        }

        // Redeem Code Function
        function redeemCode() {
            const code = redeemCodeInput.value.trim().toUpperCase();
            let reward = 0;
            let message = "";

            switch (code) {
                case 'RAAJ':
                    reward = 500;
                    message = "You redeemed RAAJ! +500 Coins!";
                    break;
                case 'RAJITH':
                    reward = 2000;
                    message = "You redeemed RAJITH! +2000 Coins!";
                    break;
                case 'TONY':
                    reward = 1000000; // A million coins!
                    message = "You redeemed TONY! A MILLION COINS! You're rich!";
                    break;
                default:
                    message = "Invalid or expired code.";
                    break;
            }

            if (reward > 0) {
                coins += reward;
                updateCoins();
                redeemCodeInput.value = ''; // Clear input
                playSound('powerup');
            }
            showMessage("Redeem Code", message);
        }

        // Nitro Activation (now triggered by right-half screen touch/hold)
        function activateNitro() {
            if (nitroCooldownTimer <= 0) {
                nitroActive = true;
                playSound('nitro');
                triggerCameraShake(CAMERA_SHAKE_INTENSITY * 1.5, NITRO_DURATION);
                setTimeout(() => {
                    nitroActive = false;
                    nitroCooldownTimer = nitroCooldown; // Use dynamic cooldown
                }, NITRO_DURATION);
            }
        }

        // Start the game when the window loads
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>
